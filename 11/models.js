// Generated by CoffeeScript 1.4.0
(function() {
  var B, N, T, TT, binormal, electron, fparams, frame, frameparams, frametrol, h, mathmodels, normal, p, path, pp, speedtrol, startmodels, tangent, tg, tgnrparams, tgparams, tgspeedtrol, tgtrol, tn, tnparams, tntrol, torus, tparams, update;

  MathModel.statustext = $("#modelstatus");

  h = 0.01;

  p = function(t) {
    return new THREE.Vector3(Math.cos(t) * (2 - Math.cos(4 * t)), Math.sin(t) * (2 - Math.cos(4 * t)), Math.sin(4 * t));
  };

  pp = function(t) {
    return (p(t + h).subSelf(p(t))).divideScalar(h);
  };

  T = function(t) {
    return pp(t).normalize();
  };

  TT = function(t) {
    return (T(t + h).subSelf(T(t))).divideScalar(h);
  };

  N = function(t) {
    return TT(t).normalize();
  };

  B = function(t) {
    return T(t).crossSelf(N(t));
  };

  torus = function(model) {
    model.torus = new THREE.Mesh(new THREE.TorusGeometry(2, 1, 64, 48), new THREE.MeshPhongMaterial({
      ambient: 0x555555,
      color: 0xee0000,
      emissive: 0xee0000,
      specular: 0x123456,
      shininess: 5,
      opacity: 0.7,
      transparent: true
    }));
    model.torus.position.set(0, 0, 0);
    model.scene.add(model.torus);
    return null;
  };

  electron = function(model) {
    model.electron = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshLambertMaterial({
      ambient: 0x555555,
      color: 0xffff00,
      reflectivity: 100
    }));
    model.electron.position.set(1, 0, 0);
    model.scene.add(model.electron);
    return null;
  };

  tangent = function(model) {
    model.tgt = new THREE.ArrowHelper(T(0), p(0), 1.0, 0x00ff00);
    return model.tgt;
  };

  normal = function(model) {
    model.nrml = new THREE.ArrowHelper(T(0), p(0), 1.0, 0xff00ff);
    return model.nrml;
  };

  binormal = function(model) {
    model.binormal = new THREE.ArrowHelper(T(0), p(0), 1.0, 0x0000ff);
    return model.binormal;
  };

  path = function(model) {
    model.pathGeo = new THREE.Geometry();
    model.s = 0;
    while (model.s <= 2 * Math.PI) {
      model.pathGeo.vertices.push(p(model.s));
      model.s += 0.005;
    }
    model.pathMat = new THREE.LineBasicMaterial({
      color: 0x998800,
      lineWidth: 10
    });
    model.path = new THREE.Line(model.pathGeo, model.pathMat);
    return model.path;
  };

  update = function(vector, f, time) {
    vector.setDirection(f(time));
    return vector.position = p(time);
  };

  frameparams = function() {
    this.speed = 0.5;
    this.solid = true;
    return null;
  };

  fparams = new frameparams();

  frame = new MathModel();

  frame.container = document.getElementById("wholeframecontainer");

  frame.solid = fparams.solid;

  frame.speed = fparams.speed;

  frame.populate();

  frame.camera.position.set(0, 0, 8);

  torus(frame);

  electron(frame);

  frame.scene.add(tangent(frame));

  frame.scene.add(normal(frame));

  frame.scene.add(binormal(frame));

  frame.scene.add(path(frame));

  frame.calc = function(t) {
    var time;
    time = frame.speed * 0.001 * t;
    frame.electron.position = p(time);
    update(frame.tgt, T, time);
    update(frame.nrml, N, time);
    update(frame.binormal, B, time);
    return null;
  };

  frame.gui = new dat.GUI({
    autoPlace: false
  });

  $("#wholeframecontrols").append(frame.gui.domElement);

  frametrol = frame.gui.add(fparams, "solid");

  frametrol.onChange(function(value) {
    frame.torus.visible = value;
    return null;
  });

  speedtrol = frame.gui.add(fparams, "speed", 0, 1);

  speedtrol.onChange(function(value) {
    frame.speed = value;
    return null;
  });

  tgparams = function() {
    this.speed = 0.5;
    this.solid = true;
    return null;
  };

  tparams = new tgparams();

  tg = new MathModel();

  tg.container = document.getElementById("tangentcontainer");

  tg.solid = tparams.solid;

  tg.speed = tparams.speed;

  tg.populate();

  tg.camera.position.set(0, 0, 8);

  torus(tg);

  electron(tg);

  tg.scene.add(tangent(tg));

  tg.scene.add(path(tg));

  tg.calc = function(t) {
    var time;
    time = tg.speed * 0.001 * t;
    tg.electron.position = p(time);
    update(tg.tgt, T, time);
    return null;
  };

  tg.gui = new dat.GUI({
    autoPlace: false
  });

  $("#tangentcontrols").append(tg.gui.domElement);

  tgtrol = tg.gui.add(tparams, "solid");

  tgtrol.onChange(function(value) {
    tg.torus.visible = value;
    return null;
  });

  tgspeedtrol = tg.gui.add(tparams, "speed", 0, 1);

  tgspeedtrol.onChange(function(value) {
    tg.speed = value;
    return null;
  });

  tgnrparams = function() {
    this.speed = 0.5;
    this.solid = true;
    return null;
  };

  tnparams = new tgnrparams();

  tn = new MathModel();

  tn.container = document.getElementById("tangentnormalcontainer");

  tn.solid = tnparams.solid;

  tn.speed = tnparams.speed;

  tn.populate();

  tn.camera.position.set(0, 0, 8);

  torus(tn);

  electron(tn);

  tn.scene.add(tangent(tn));

  tn.scene.add(normal(tn));

  tn.scene.add(path(tn));

  tn.calc = function(t) {
    var time;
    time = tn.speed * 0.001 * t;
    tn.electron.position = p(time);
    update(tn.tgt, T, time);
    update(tn.nrml, N, time);
    return null;
  };

  tn.gui = new dat.GUI({
    autoPlace: false
  });

  $("#tangentnormalcontrols").append(tn.gui.domElement);

  tntrol = tn.gui.add(tnparams, "solid");

  tntrol.onChange(function(value) {
    tn.torus.visible = value;
    return null;
  });

  speedtrol = tn.gui.add(tnparams, "speed", 0, 1);

  speedtrol.onChange(function(value) {
    tn.speed = value;
    return null;
  });

  mathmodels = [frame, tn, tg];

  window.LoadedMathModels = mathmodels;

  startmodels = function() {
    var model, _i, _len;
    for (_i = 0, _len = mathmodels.length; _i < _len; _i++) {
      model = mathmodels[_i];
      model.go();
    }
    return null;
  };

  $(document).ready(function() {
    startmodels();
    return null;
  });

}).call(this);
