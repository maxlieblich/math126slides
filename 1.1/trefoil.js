// Generated by CoffeeScript 1.6.3
(function() {
  var ellipsoid, frame, heart, invertNormals, setup_renderer, sphere;

  setup_renderer = function(renderer, container, WIDTH, HEIGHT) {
    renderer.setSize(WIDTH, HEIGHT);
    renderer.domElement.style.position = "relative";
    $(container).append(renderer.domElement);
    renderer.clear();
    return null;
  };

  invertNormals = function(geo) {
    var face, foose, _i, _len, _ref;
    _ref = geo.faces;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      face = _ref[_i];
      foose = new THREE.Face3(face.a, face.b, face.c);
      face.a = foose.c;
      face.c = foose.a;
    }
    geo.computeFaceNormals();
    geo.computeVertexNormals();
    return null;
  };

  frame = function() {
    var HEIGHT, WIDTH, ambient, drawPath, implant, line, mat, self, trefoilFunc, trefoilPoint, trefoilgeom;
    self = this;
    WIDTH = 550;
    HEIGHT = 450;
    self.scene = new THREE.Scene();
    self.container = document.getElementById("trefoilcontainer");
    self.camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 1, 1000);
    self.camera.position.set(0, 4, 3);
    self.camera.up = new THREE.Vector3(0, 0, 1);
    self.scene.add(self.camera);
    self.cameraControls = new THREE.TrackballControls(self.camera, self.container);
    self.cameraControls.target.set(0, 0, 0);
    ambient = new THREE.AmbientLight(0xffffff);
    self.scene.add(ambient);
    self.pointLight = new THREE.PointLight(0xffffff);
    self.pointLight.intensity = 0.1;
    self.pointLight.position.set(0, 0, 10);
    self.scene.add(self.pointLight);
    if (Detector.webgl) {
      self.renderer = new THREE.WebGLRenderer({
        antialias: true,
        preserve: true
      });
    } else {
      self.renderer = new THREE.CanvasRenderer;
    }
    setup_renderer(self.renderer, self.container, WIDTH, HEIGHT);
    mat = new THREE.MeshNormalMaterial;
    trefoilFunc = function(t) {
      var t2, t3;
      t2 = t + t;
      t3 = t2 + t;
      return 41 * Math.cos(t) - 18 * Math.sin(t) - 83 * Math.cos(t2) - 83 * Math.sin(t2) - 11 * Math.cos(t3) + 27 * Math.sin(t3);
    };
    trefoilPoint = function(t) {
      var kScale, x, y, z;
      kScale = 0.01;
      x = trefoilFunc(t);
      y = trefoilFunc(6.283185 - t);
      z = trefoilFunc(t - 1.828453);
      return new THREE.Vector3(kScale * x, kScale * y, kScale * z);
    };
    drawPath = function(T) {
      var points, t;
      points = [];
      t = 0;
      while (t <= T) {
        points.push(trefoilPoint(t));
        t += 0.01;
      }
      return points;
    };
    self.trefoilcurve = new THREE.SplineCurve3(drawPath(6.28));
    trefoilgeom = new THREE.Geometry();
    trefoilgeom.vertices = drawPath(6.28);
    line = new THREE.Line(trefoilgeom);
    line.position.set(0, 0, 0);
    line.rotation.set(0, 0, 0);
    line.scale.set(1, 1, 1);
    self.scene.add(line);
    self.sphere = new THREE.Mesh(new THREE.SphereGeometry(0.05, 0.1, 0.1), new THREE.MeshNormalMaterial());
    self.scene.add(self.sphere);
    implant = function(geometry) {
      self.scene.add(new THREE.Mesh(geometry, mat));
      return null;
    };
    self.rendering = false;
    this.renderloop = function() {
      self = this;
      self.rendering = true;
      self.update = function() {
        self.sphere.position = self.trefoilcurve.getPoint(new Date().getTime() / 6280.0 % 1);
        self.cameraControls.update();
        self.pointLight.position = self.camera.position;
        self.renderer.render(self.scene, self.camera);
        return null;
      };
      self.animate = function(t) {
        self.update();
        if (self.rendering) {
          requestAnimationFrame(self.animate, self.container);
        }
        return null;
      };
      self.animate(new Date().getTime());
      return null;
    };
    return null;
  };

  heart = function() {
    var HEIGHT, WIDTH, ambient, generateNormals, implant, loader, mat, self;
    self = this;
    WIDTH = 550;
    HEIGHT = 450;
    self.scene = new THREE.Scene();
    self.container = document.getElementById("heartcontainer");
    self.camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 1, 1000);
    self.camera.position.set(0, 4, 3);
    self.camera.up = new THREE.Vector3(0, 0, 1);
    self.scene.add(self.camera);
    self.cameraControls = new THREE.TrackballControls(self.camera, self.container);
    self.cameraControls.target.set(0, 0, 0);
    ambient = new THREE.AmbientLight(0xffffff);
    self.scene.add(ambient);
    self.pointLight = new THREE.PointLight(0xffffff);
    self.pointLight.intensity = 0.1;
    self.pointLight.position.set(0, 0, 10);
    self.scene.add(self.pointLight);
    if (Detector.webgl) {
      self.renderer = new THREE.WebGLRenderer({
        antialias: true,
        preserve: true
      });
    } else {
      self.renderer = new THREE.CanvasRenderer;
    }
    setup_renderer(self.renderer, self.container, WIDTH, HEIGHT);
    mat = new THREE.MeshNormalMaterial;
    implant = function(geometry) {
      self.scene.add(new THREE.Mesh(geometry, mat));
      generateNormals(geometry);
      return null;
    };
    loader = new THREE.JSONLoader(true);
    loader.load("heart.json", implant);
    self.rendering = false;
    generateNormals = function(geometry) {
      var face, faces, i, point, _i;
      geometry.computeFaceNormals();
      faces = geometry.faces;
      for (i = _i = 0; _i <= 100; i = ++_i) {
        face = faces[76453 * i % faces.length];
        point = THREE.GeometryUtils.randomPointInFace(face, geometry);
        self.scene.add(new THREE.ArrowHelper(face.normal, point, 0.3, 0xff0000));
      }
      return null;
    };
    this.renderloop = function() {
      self = this;
      self.rendering = true;
      self.update = function() {
        self.cameraControls.update();
        self.pointLight.position = self.camera.position;
        self.renderer.render(self.scene, self.camera);
        return null;
      };
      self.animate = function(t) {
        self.update();
        if (self.rendering) {
          requestAnimationFrame(self.animate, self.container);
        }
        return null;
      };
      self.animate(new Date().getTime());
      return null;
    };
    return null;
  };

  sphere = function() {
    var HEIGHT, WIDTH, ambient, implant, loader, mat, self;
    self = this;
    WIDTH = 550;
    HEIGHT = 450;
    self.scene = new THREE.Scene();
    self.container = document.getElementById("spherecontainer");
    self.camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 1, 1000);
    self.camera.position.set(0, 4, 3);
    self.camera.up = new THREE.Vector3(0, 0, 1);
    self.scene.add(self.camera);
    self.cameraControls = new THREE.TrackballControls(self.camera, self.container);
    self.cameraControls.target.set(0, 0, 0);
    ambient = new THREE.AmbientLight(0xffffff);
    self.scene.add(ambient);
    self.pointLight = new THREE.PointLight(0xffffff);
    self.pointLight.intensity = 0.1;
    self.pointLight.position.set(0, 0, 10);
    self.scene.add(self.pointLight);
    if (Detector.webgl) {
      self.renderer = new THREE.WebGLRenderer({
        antialias: true,
        preserve: true
      });
    } else {
      self.renderer = new THREE.CanvasRenderer;
    }
    setup_renderer(self.renderer, self.container, WIDTH, HEIGHT);
    mat = new THREE.MeshNormalMaterial;
    implant = function(geometry) {
      self.scene.add(new THREE.Mesh(geometry, mat));
      generateNormals(geometry);
      return null;
    };
    loader = new THREE.JSONLoader(true);
    loader.load("sphere.json", implant);
    self.rendering = false;
    this.renderloop = function() {
      self = this;
      self.rendering = true;
      self.update = function() {
        self.cameraControls.update();
        self.pointLight.position = self.camera.position;
        self.renderer.render(self.scene, self.camera);
        return null;
      };
      self.animate = function(t) {
        self.update();
        if (self.rendering) {
          requestAnimationFrame(self.animate, self.container);
        }
        return null;
      };
      self.animate(new Date().getTime());
      return null;
    };
    return null;
  };

  ellipsoid = function() {
    var HEIGHT, WIDTH, ambient, implant, loader, mat, self;
    self = this;
    WIDTH = 550;
    HEIGHT = 450;
    self.scene = new THREE.Scene();
    self.container = document.getElementById("ellipsoidcontainer");
    self.camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 1, 1000);
    self.camera.position.set(0, 4, 3);
    self.camera.up = new THREE.Vector3(0, 0, 1);
    self.scene.add(self.camera);
    self.cameraControls = new THREE.TrackballControls(self.camera, self.container);
    self.cameraControls.target.set(0, 0, 0);
    ambient = new THREE.AmbientLight(0xffffff);
    self.scene.add(ambient);
    self.pointLight = new THREE.PointLight(0xffffff);
    self.pointLight.intensity = 0.1;
    self.pointLight.position.set(0, 0, 10);
    self.scene.add(self.pointLight);
    if (Detector.webgl) {
      self.renderer = new THREE.WebGLRenderer({
        antialias: true,
        preserve: true
      });
    } else {
      self.renderer = new THREE.CanvasRenderer;
    }
    setup_renderer(self.renderer, self.container, WIDTH, HEIGHT);
    mat = new THREE.MeshNormalMaterial;
    implant = function(geometry) {
      self.scene.add(new THREE.Mesh(geometry, mat));
      return null;
    };
    loader = new THREE.JSONLoader(true);
    loader.load("ellipsoid.json", implant);
    self.rendering = false;
    this.renderloop = function() {
      self = this;
      self.rendering = true;
      self.update = function() {
        self.cameraControls.update();
        self.pointLight.position = self.camera.position;
        self.renderer.render(self.scene, self.camera);
        return null;
      };
      self.animate = function(t) {
        self.update();
        if (self.rendering) {
          requestAnimationFrame(self.animate, self.container);
        }
        return null;
      };
      self.animate(new Date().getTime());
      return null;
    };
    return null;
  };

  frame = new frame();

  window.frame = frame;

  window.frame.rendering = false;

  $(document).bind('deck.change', function(event, from, to) {
    if ($('.deck-current').find('#trefoilcontainer').length + $('.deck-next').find('#trefoilcontainer').length + $('.deck-previous').find('#trefoilcontainer').length && window.frame.rendering === false) {
      frame.renderloop();
    } else {
      window.frame.rendering = false;
    }
  });

  heart = new heart();

  window.heart = heart;

  window.heart.rendering = false;

  $(document).bind('deck.change', function(event, from, to) {
    if ($('.deck-current').find('#heartcontainer').length + $('.deck-next').find('#heartcontainer').length + $('.deck-previous').find('#heartcontainer').length && window.heart.rendering === false) {
      heart.renderloop();
    } else {
      window.heart.rendering = false;
    }
  });

  sphere = new sphere();

  window.sphere = sphere;

  window.sphere.rendering = false;

  $(document).bind('deck.change', function(event, from, to) {
    if ($('.deck-current').find('#spherecontainer').length + $('.deck-next').find('#spherecontainer').length + $('.deck-previous').find('#spherecontainer').length && window.sphere.rendering === false) {
      sphere.renderloop();
    } else {
      window.sphere.rendering = false;
    }
  });

  ellipsoid = new ellipsoid();

  window.ellipsoid = ellipsoid;

  window.ellipsoid.rendering = false;

  $(document).bind('deck.change', function(event, from, to) {
    if ($('.deck-current').find('#ellipsoidcontainer').length + $('.deck-next').find('#ellipsoidcontainer').length + $('.deck-previous').find('#ellipsoidcontainer').length && window.ellipsoid.rendering === false) {
      ellipsoid.renderloop();
    } else {
      window.ellipsoid.rendering = false;
    }
  });

}).call(this);
